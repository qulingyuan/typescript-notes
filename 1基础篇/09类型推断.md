# 类型检查机制

TypeScript 编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。

作用：辅助开发，提高开发效率。

- 类型推断
- 类型兼容性
- 类型保护

## 类型推断

不需要指定变量的类型（函数的返回值类型），TypeScript 可以根据某些规则自动地为其推断出一个类型。

### 基础类型推断

Ts 中比较常见的类型推断，通常发生在以下场景：

初始化变量时：

```typescript
let a = 1; // number
```

### 最佳通用类型推断

当需要从多个类型中推断出一个类型的时候，ts 就会尽可能的推断出一个兼容当前所有类型的通用类型：

```typescript
let b = [1, null, 'a'] //(number|null|string)[]
```

函数参数赋默认值以及确定函数返回值时：

```typescript
let d = (x = 1) => x + 1 // (x?:number)=>number
```

### 上下文类型推断

以上的类型推断都是从右向左的推断，也就是根据表达式右侧的值来推断表达式左侧变量的类型。还有一种类型推断是从左向右，这种就是上下文类型推断，这种通常会发生在**事件处理**中。

```typescript
window.onkeydown = (event) => {  // KeyBoardEvent
    // console.log(event.button)
} 
```

Ts会根据左侧的事件绑定来推断出右侧的事件类型，上面的 event 会被推断为 KeyBoardEvent，同时，ts 也会知道这个 event 相应的属性是什么，会在我们调用的时候进行相应提示。

### 类型断言

有时候 ts 的类型推断可能不符合你的预期，而且你完全有自信比 ts 更了解你的代码，这时 ts 提供了一种方法允许你覆盖它的推论，这就是类型断言。

```typescript
let foo = {}
foo.bar = 1; 
==============================
# 类型'{}'上不存在属性'bar'
```

我们可以用类型断言解决上面的错误

```typescript
interface Foo{
	bar:number
}
let foo = {} as Foo
foo.bar = 1;
```

但类型断言不能乱用，如果遗漏了上面的`foo.bar = 1;`这一行，就会出现问题。

所以建议在声明对象的时候，就直接把对象指定为上面的接口类型：

```typescript
interface Foo {
	bar: number
}
let foo: Foo = {
  bar: 1
}
```

类型断言会增加我们代码的灵活性，在改造旧代码的时候会非常有效，但是使用类型断言要避免滥用，要对上下文环境有充分的预判，没有任何根据的类型断言会给代码带来安全隐患。

