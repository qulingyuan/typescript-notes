## 类型兼容性

当一个类型 y 可以被赋值给另一个类型 x 时，我们就可以说类型 x 兼容类型 y。

x 兼容 y : x ( 目标类型 ) = y ( 源类型 )

在`strictNullChecks`选项为 false 时，字符串类型的变量可以被赋值为 null，即字符串类型兼容 null 类型。

```typescript
let s: string = 'a';
s = null;
```

### 接口兼容性

```typescript
// 接口兼容性
interface X {
    a: any;
    b: any;
}
interface Y {
    a: any;
    b: any;
    c: any;
}
let x: X = {a: 1, b: 2}
let y: Y = {a: 1, b: 2, c: 3}
x = y //yes
y = x //no
```

上面例子可以看出，y 接口只要具有 x 接口的所有属性，那么即使 y 接口有额外的属性，那么 y 接口任然被认为是 x 类型，也就是 x 类型可以兼容 y 类型。

源类型必须具备目标类型的必要属性，才可以进行赋值。

接口之间类型兼容的时候，成员少的会兼容成员多的。

### 函数兼容性

需要判断两个函数是否兼容通常发生在两个函数相互赋值的情况下，也就是函数作为参数的情况下：

```typescript
type Handler = (a: number, b: number) => void
function hof(handler: Handler) {
    return handler
}
```

目标函数兼容源函数，需要满足三个条件：

1. #### 参数的个数：

  目标函数的参数个数必须多于源函数的参数个数。

```typescript
let handler1 = (a: number) => {}
hof(handler1)  //yes
let handler2 = (a: number, b: number, c: number) => {}
hof(handler2)  //no
==================================
类型"(a:number,b:number,c:number)=>void"的参数是不能赋值给类型"Handler"的参数
```

以上情况都是针对具有固定参数的函数，如果函数中具有可选参数或剩余参数的情况的情况，参考以下情况。

2. #### 可选参数和剩余参数

固定参数是可以兼容可选参数或剩余参数的。

可选参数是不兼容固定参数或剩余参数的。可以通过设置`strictFunctionTypes`为 `false`来实现兼容。

剩余参数可以兼容固定参数或可选参数。

```typescript
// 可选参数和剩余参数
let a = (p1: number, p2: number) => {}
let b = (p1?: number, p2?: number) => {}
let c = (...args: number[]) => {}
a = b //yes
a = c //yes
b = a //no
b = c	//no
c = a //yes
c = b //yes
```

3. 参数类型

